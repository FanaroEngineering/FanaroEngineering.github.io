<!DOCTYPE html>
<html lang="en">
  <head>
    <title>FIC: Fast Immutable Collections</title>

    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />

    <meta name="author" content="Philippe Fanaro" />
    <meta name="description" content="FIC: Fast Immutable Collections" />

    <meta property="og:image" content="assets/logo_400.png" />
    <meta property="og:description" content="FIC: Fast Immutable Collections" />
    <meta property="og:title" content="FIC: Fast Immutable Collections" />
    <meta property="og:site_name" content="fanaro.io" />
    <meta property="og:type" content="blog" />

    <script src="index.js"></script>

    <link rel="stylesheet" href="index.css" />
    <link rel="icon" type="image/svg+xml" href="assets/favicon.png" />
  </head>
  <body>
    <article>
      <img src="fic.png" alt="FIC Logo" />

      <h1>FIC: Fast Immutable Collections</h1>

      <p>
        Have you ever wondered if there was a way of getting rid of the plague
        of mutability in OOP and imperative languages? Or maybe restrict it? If
        you did, you're not alone.
      </p>

      <p>
        Managing many objects each inside their respective architectural layers
        can be an even bigger challenge if they keep unexpectedly changing
        throughout their lifetimes. Joshua Bloch even goes so far as to state in <em>Effective Java</em>:
      </p>

      <!-- TODO: Mention Effective Java's best practice of making objects immutable by default. -->
      <blockquote></blockquote>

      <!-- TODO: Mention the part of the README that says that objects inside an immutable object need to be immutable. -->

      <!-- TODO: Mention the extensive amount of resources in the README file. -->

      <!-- TODO: Mention a link to the video on how Clojure manages its immutable data: through the HAMT. -->
      <!-- TODO: Also mention that this would be the main alternative for when redesigning the project. -->
    </article>
  </body>
</html>
