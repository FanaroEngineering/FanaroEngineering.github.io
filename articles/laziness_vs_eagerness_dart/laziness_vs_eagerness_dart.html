<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Laziness vs Eagerness in Dart</title>

    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />

    <meta name="author" content="Philippe Fanaro" />
    <meta name="description" content="Laziness vs Eagerness in Dart" />

    <meta property="og:image" content="thumbnail.png" />
    <meta property="og:description" content="Laziness vs Eagerness in Dart" />
    <meta property="og:title" content="Laziness vs Eagerness in Dart" />
    <meta property="og:site_name" content="fanaro.io" />
    <meta property="og:type" content="blog" />

    <script src="../../index.js"></script>

    <link rel="stylesheet" href="../../index.css" />
    <link rel="icon" type="image/svg+xml" href="../../assets/favicon.svg" />

    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.4.1/styles/atom-one-dark.min.css"
    />
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.5.0/build/highlight.min.js"></script>
    <script defer>
      hljs.initHighlightingOnLoad();
    </script>
  </head>
  <body>
    <article>
      <h1>Laziness vs Eagerness in Dart</h1>

      <p>
        This article is inspired by some of weirdness we faced when developing
        my and Marcelo's immutable collections package,
        <local-link
          text="Fast Immutable Collections (FIC)"
          link="../fic/fic.html"
        ></local-link>
        package. Both the examples in the first section were actually created by
        <a href="https://github.com/marcglasberg">Marcelo Glasberg</a>, all I
        did was add some more explanations and rice them up.
      </p>

      <section>
        <custom-h2 text="Why should I care?"></custom-h2>

        <p>
          What's discussed in this article is specially relevant if you happened
          to "mix" <code>Iterable</code> and <code>List</code>,
          <code>Set</code>, etc. Mixing those types can be useful, for example,
          when you have an object that could accept more than one type of
          collection.
        </p>

        <custom-h3 text="Number of Evaluations"></custom-h3>

        <p>
          If I presented you with the following code, what would your
          expectations be? What would be your bets for each counter?
        </p>

        <blockquote>
          Note the <code>.where</code> method returns an <code>Iterable</code>,
          even when on a <code>List</code> or <code>Set</code>.
        </blockquote>

        <pre><code class="dart">var lazyCounter = 0;
var eagerCounter = 0;

var lazyOddFilter = [1, 2, 3, 4, 5, 6, 7].where((i) {
  lazyCounter++;
  return i % 2 == 0;
});

var evenFilterEager = [1, 2, 3, 4, 5, 6, 7].where((i) {
  eagerCounter++;
  return i % 2 == 0;
}).toList();

print("\n\n---------- Init ----------\n\n");

lazyOddFilter.length;
lazyOddFilter.length;
lazyOddFilter.length;

evenFilterEager.length;
evenFilterEager.length;
evenFilterEager.length;

print("\n\n---------- Lazy vs Eager ----------\n\n");

print("Lazy: $lazyCounter");
print("Eager: $eagerCounter");

print("\n\n---------- END ----------\n\n");</code></pre>

        <p>Do the results below suprise you?</p>

        <pre><code>Lazy: 21
Eager: 7</code></pre>

        <p>
          How would you go about explaining them, even if you did get them
          right?
        </p>

        <p>
          Quite frankly, I would bet 8:2 you got it wrong, as did I, at least on
          the first try. The language used in the example also contributes to
          the misunderstanding: who wouldn't simply trivially assume that the
          eager version wouldn't be the one overdoing things?
        </p>

        <p>
          The reason for what happened above comes from the fact that the lazy
          filter actually doesn't return a thing, it returns an object that
          carries the operation to return a thing. So, every time you want to
          really know the result of the operation, the lazy object has to
          evaluate the operation, it has no memory and it doesn't evaluate the
          operation at first. The eager version, on the other hand, does
          everything right away and does remember the results.
        </p>

        <custom-h3 text="Evaluation Order"></custom-h3>

        <p>
          Ok, that was weird. But, most of the time, performance isn't really
          the problem, specially since computers have got so fast<foot-note
            text="Oh, have they really?"
          ></foot-note
          >. Debugging and readability tend to be much more relevant and
          recurrent problems during development. So why should we care?
        </p>

        <p>
          The when things happen can affect the order in which things happen.
          Debugging will certainly be more difficult if you're not aware of
          what's happening when, and readability will suffer if what you write
          doesn't represent 100% what's going on.
        </p>

        <p>
          Let's take a look at the following example, try predicting the order
          in which each method will be called in each case:
        </p>

        <pre><code class="dart">int eagerCounter = 0;
int lazyCounter = 0;

List&lt;int&gt; removeOdd_eager(Iterable&lt;int&gt; source) {
  return source.where((i) {
    eagerCounter++;
    print("removeOdd_eager");
    return i % 2 == 0;
  }).toList();
}

List&lt;int&gt; removeLessThan10_eager(Iterable&lt;int&gt; source) {
  return source.where((i) {
    eagerCounter++;
    print("removeLessThan10_eager");
    return i &gt;= 10;
  }).toList();
}

Iterable&lt;int&gt; removeOdd_lazy(Iterable&lt;int&gt; source) {
  return source.where((i) {
    print("removeOdd_lazy");
    lazyCounter++;
    return i % 2 == 0;
  });
}

Iterable&lt;int&gt; removeLessThan10_lazy(Iterable&lt;int&gt; source) {
  return source.where((i) {
    print("removeLessThan10_lazy");
    lazyCounter++;
    return i &gt;= 10;
  });
}

var list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];

print("\n\n---------- Init ----------\n\n");

Iterable&lt;int&gt; eager = removeLessThan10_eager(removeOdd_eager(list));

Iterable&lt;int&gt; lazy = removeLessThan10_lazy(removeOdd_lazy(list));

print("\n\n---------- Lazy ----------\n\n");

// Note que, para Iterables, Dart imprime com `()`; e, para List, com `[]`.
print(lazy);

print("\n\n---------- Eager ----------\n\n");

print(eager);

print("\n\n---------- Counters ----------\n\n");

print("Lazy: $lazyCounter");
print("Eager: $eagerCounter");

print("\n\n---------- END ----------\n\n");</code></pre>

        <blockquote>
          Note that <code>Iterable</code>s print <code>()</code> when logged,
          while <code>List</code>s print <code>[]</code>, and,
          <code>Set</code>s, <code>{}</code>.
        </blockquote>
        <p>
          I won't print the output of the code above here. This article is
          already long enough. You can run all the code from
          <local-link
            text="this file"
            link="lazy_vs_eager_test.dart"
          ></local-link
          >, but, long story short, you will see that the eager version of the
          compound operations above will first solve all of the inner operations
          and then pass everything to the outer function; while the lazy version
          will do things whenever they're needed. All that means is: if you're
          going for the lazy version, when debugging, you might end up with logs
          and results of both functions mixed together, which will very likely
          make things more difficult to solve. Lazy functions and methods are
          much more easilly debugged atomically than when put together with
          other lazy abstractions.
        </p>

        <blockquote>
          Laziness seems to have been historically very appealing to academia
          and mathematicians. Typically, those individuals don't care about
          <strike>concrete results</strike> numerical results, only that their
          shapes are correct. <em>Functional</em> languages like Haskell are,
          for instance, lazy by default.
        </blockquote>
      </section>

      <section>
        <custom-h2 text="The Weird World of Iterables"></custom-h2>

        <!-- TODO: Mention IterableMixin, ListMixin, SetMixin and MapMixin -->
        <!-- TODO: Pagination makes it less bad to use `Iterable` -->

        <custom-h3 text="The Pros and Cons"></custom-h3>

        <!-- TODO: Mention why `List` should be the first choice most of the time-->

        <custom-h3 text="Infinity"></custom-h3>

        <custom-h3
          text="One of The Main Benefits of Implementing Iterable: &lt;code&gt;for (... in ...) {}&lt;/code&gt;"
        ></custom-h3>
      </section>

      <section>
        <custom-h2 text="Extras"></custom-h2>

        <custom-h3 text="Tail Call Optimization (TCO)"></custom-h3>

        <custom-h3
          text="Why Dart choose <code>Iterable</code> for its design"
        ></custom-h3>
      </section>
    </article>
  </body>
</html>
